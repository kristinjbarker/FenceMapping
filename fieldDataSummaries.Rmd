---
title: "Fence inventory field data"
author: "Kristin Barker"
date: "2024-10-23"
output: html_document
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)

  # packages(list needed; install missing; load all)
  packages <- c(
    "lubridate", # datetimes
    "cowplot", # muti-panel plotting
    "sf", # tidy spatdat
    "stringr", # cleaning names etc
    "tidyverse") # life
  ipak <- function(pkg){
    new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
    if (length(new.pkg)) 
      install.packages(new.pkg, dependencies = TRUE)
    sapply(pkg, require, character.only = TRUE)
  }    
  ipak(packages) ; rm(ipak, packages)



  # raw data (exported via Feature Class to Feature Class tool in ArcPro from fence group)
  rawFences <- read_sf("../../Data/Fencemapping/rawFencelines.shp")
  rawFeatures <- read_sf("../../Data/Fencemapping/rawFenceFeatures.shp")
  rawWildlife <- read_sf("../../Data/Fencemapping/rawWildlifeObservations.shp")
  rawRange <- read_sf("../../Data/Fencemapping/rawRangeImprovements.shp")
  rawUSFSall <- read_sf("../../Data/Fencemapping/SNFpasturesNW.shp")
  rawUSFSmapped <- read_sf("../../Data/Fencemapping/SNFmappedOnly.shp")
  
  # all names entered as data collectors (need cleaning)
  rawCollectors <- sort(unique(c(rawFences$Collector_, 
                                 rawFeatures$Collector_, 
                                 rawWildlife$Collector_,
                                 rawRange$Collector_)))
```

## Fence inventory on the Absaroka Front

Pretend this is a cute summary of the background and need

## 
```{r prep, echo = FALSE}


## *Functions are specific to summer 2024 field season but are easily modified

# Clean and standardize names of data collectors
  clean_collector <- function(name) {
    # Common typos/variations, IDed from rawCollectors
    if (str_detect(name, "lliso|bald|basin")) {
      return("Allison Stoff") 
    } else if (str_detect(name, "eth full")) {
      return("Beth Fuller")
    } else if (str_detect(name, "lemi|tristen|tristn")) {
      return("Tristen Fleming")
    } else if (str_detect(name, "hayden")) {
      return("Hayden Campbell")
    } else if (str_detect(name, "ean jeff")) {
      return("Dean Jeffers")
    } else if (str_detect(name, "bha")) {
      return("Andrew Hahne")
    } else if (str_detect(name, "^er$")) {
      return("Emily Reed")
    } else if (str_detect(name, "brut")) {
      return("Jaden Brutsman")
    } 
    # Make names title case
    return(str_to_title(name))
  }


# Match names to organizations
clean_org <- function(name) {
  if (str_detect(name, "Allison Stoff|Tristen Fleming|Hayden Campbell|Jaden Brutsman|KristinBarker")) {
    return("BYLL")
  } else if (str_detect(name, "Kimi")) {
    return("TNC") 
  } else if (str_detect(name, "Emily Reed")) {
    return("AFI")
  } else if (str_detect(name, "Andrew Hahne|Madison Clarke|Dean Jeffers")) {
    return("BHA")
  }
  return("UnkOther")
}
```

```{r clean, echo = FALSE}

# fencelines
datFences <- rawFences %>%
  # remove spatial attributes
  st_drop_geometry() %>%
  # make names characters and make all lowercase for easier string matching
  mutate(Collector_ = ifelse(is.na(Collector_), "NA", tolower(Collector_))) %>%
  # remove anything collected on training day
  filter(Date_of_Co != "2024-06-05") %>%
  # clean and standardize names of collectors
  mutate(collector = as.character(sapply(Collector_, clean_collector))) %>%
  # add organization name based on collector name
  mutate(group = as.character(sapply(collector, clean_org))) %>%
  # add field season
  mutate(fieldSeason = ifelse(EditDate > "2024-06-05", "summer2024", NA),
         withNewApp = ifelse(Editor == "shapiroPython", "no", "yes")) %>%
  # combine standard and nonstandard wire heights
  mutate(wireHeights = ifelse(Fence_Wire == "Other", Fence_Wi_1, Fence_Wire)) %>%
  # make column names more intuitive
  rename(fenceID = AFI_FenceI,
         type = Fence_Mate,
         material = Material_T,
         numberWires = Num_Wires,
         numberPoles = Num_Poles,
         condition = Fence_Cond,
         landowner = Land_Agenc,
         WGFDregion = WGFD_Regio,
         dateMapped = Date_of_Co,
         dateAdded = CreationDa,
         dateEdited = EditDate,
         arcAccount = Editor,
         access = Project_Ac,
         urgency = Project_Ur,
         status = Inventory_,
         railtop = Railtop,
         comments = Comments) %>%
  # remove some extraneous columns
  dplyr::select(fenceID, type, material, 
                condition, status, urgency,
                numberWires, wireHeights, railtop,
                numberPoles, access, 
                landowner, collector, group, dateMapped,
                dateAdded, arcAccount, dateEdited,  
                fieldSeason, withNewApp, Source, Creator,
                WGFDregion, Fence_Type, Fence_Ty_1, GlobalID_1,
                comments)

# fence features
datFeatures <- rawFeatures %>%
  # remove spatial attributes
  st_drop_geometry() %>%
  # make names characters and make all lowercase for easier string matching
  mutate(Collector_ = ifelse(is.na(Collector_), "NA", tolower(Collector_))) %>%
  # remove anything collected on training day
  filter(Date_of_Co != "2024-06-05") %>%
  # clean and standardize names of collectors
  mutate(collector = as.character(sapply(Collector_, clean_collector))) %>%
  # add organization name based on collector name
  mutate(group = as.character(sapply(collector, clean_org)))

# rangeland improvements
datRange <- rawRange %>%
  # remove spatial attributes
  st_drop_geometry() %>%
  # make names characters and make all lowercase for easier string matching
  mutate(Collector_ = ifelse(is.na(Collector_), "NA", tolower(Collector_))) %>%
  # remove anything collected on training day
  filter(Date_of_Co != "2024-06-05") %>%
  # clean and standardize names of collectors
  mutate(collector = as.character(sapply(Collector_, clean_collector))) %>%
  # add organization name based on collector name
  mutate(group = as.character(sapply(collector, clean_org)))

# wildlife observations
datWildlife <- rawWildlife %>%
  # remove spatial attributes
  st_drop_geometry() %>%
  # make names characters and make all lowercase for easier string matching
  mutate(Collector_ = ifelse(is.na(Collector_), "NA", tolower(Collector_))) %>%
  # remove anything collected on training day
  filter(Date_of_Co != "2024-06-05") %>%
  # clean and standardize names of collectors
  mutate(collector = as.character(sapply(Collector_, clean_collector))) %>%
  # add organization name based on collector name
  mutate(group = as.character(sapply(collector, clean_org)))
```

```{r update spatial, include = FALSE}

# create shapefiles 

# all fences - with clean data including collectors etc
spatFences <- rawFences %>%
  dplyr::select(GlobalID_1, geometry) %>%
  inner_join(datFences) 
spatFences$length_m <- as.numeric(st_length(spatFences))

# all fences mapped during 2024 field season
spatFence2024 <- spatFences %>%
  filter(withNewApp == "yes")

# all SNF allotments near Basin
fsAll <- rawUSFSall %>%
  # match projection of fences mapped near Basin
  st_transform(crs = st_crs(rawUSFSmapped)) %>%  
  # make outlines rather than polygons
  st_cast("MULTILINESTRING") %>%
  # collapse into as few lines as possible
  st_union()

# mapped fences near Basin
fsMap <- rawUSFSmapped %>%
  st_cast("MULTILINESTRING") %>%
  st_union()

# unmapped fences

  # buffer to within 100m of a mapped fence
  fsBuff <- st_buffer(fsMap, dist = 100)
  # find fences outside the buffer
  fsRm <- st_difference(fsAll, fsBuff)
  # calculate lengths
  sum(st_length(fsRm))*0.000621371 # m to mi conversion
  sum(st_length(fsRm))/1000 # km

# area censused

  # # buffer all mapped fences from this 2024 season
  # area <- st_union(st_buffer(spatFence2024, 50))
  # plot(area)
  # area <- st_convex_hull(st_union(spatFence2024))
  # plot(area)
  # area <- st_zm(concaveman(spatFence2024, concavity = 1))
  # plot(area)
  # # forget it all this sucks i'm cavemanning it fr

```

## Quick n dirty summaries
```{r summaries}

# number of field days
length(unique(spatFence2024$dateAdded))

summ <- spatFence2024 %>%
  # remove spatial attributes
  st_drop_geometry() %>%
  summarise("Meters mapped" = sum(length_m),
            milesMapped = sum(length_m)*0.000621371,
            fieldDays = length(unique(dateAdded)),
            nUrgent = length(which(grepl("^T", spatFence2024$urgency))),
            milesPerDay = milesMapped/fieldDays) %>%
  gather() %>%
  mutate(value = round(value, 1))

summLand <-  spatFence2024 %>%
  # remove spatial attributes
  st_drop_geometry() %>%
  group_by(landowner) %>%
  summarise("Meters mapped" = sum(length_m),
            milesMapped = sum(length_m)*0.000621371) 


summ



```

```{r exports, include = FALSE}

# all fences currently in the database
st_write(spatFences,
         "../../Data/Fencemapping/fencelines.shp", append = FALSE)

# all fences mapped this season
st_write(spatFence2024,
         "../../Data/Fencemapping/fencelines2024.shp", append = FALSE)

# all fences UNmapped (check in arc)
st_write(fsRm,
         "../../Data/Fencemapping/fenceRemoved2024.shp", append = FALSE)

# quick summary tables
write.csv(summ, "summaryQuick.csv", row.names = F)
write.csv(summLand, "summaryLandownership.csv", row.names = F)

```

```{r playtime, eval = FALSE}

#### FING USFS REMOVED ####

matches <- st_intersects(fsAll, fsMap)
matches

matches <- st_is_within_distance(fsAll, fsMap, dist = 100)
matches

test <- fsAll[1][!matches,]
plot(test)


# identify all names entered as data collectors
rawCollectors <- sort(unique(c(rawFences$Collector_, rawFeatures$Collector_, rawWildlife$Collector_)))
rawCollectors

# usfs fences around Basin (for determining length of fences deleted)
spatUSFSall <- rawUSFSall %>% 
  # match crs of field data
  st_transform(crs = st_crs(rawUSFSmapped)) %>%
  # make polygons into border lines
  st_cast("MULTILINESTRING") 

# usfs fences mapped around Basin
spatUSFSmapped <- rawUSFSmapped %>%
  # match object type of all usfs 
  st_cast("MULTILINESTRING") 

# usfs fences removed from database during field mapping season
buffUSFSmapped <- st_buffer(spatUSFSmapped, dist = 100)


spatUSFSdel <- st_difference(spatUSFSall, buffUSFSmapped)

plot(spatUSFSdel[1])

# try making it just one thing for simplicity
fsAll <- fsAll[6]

plot(fsAll[1], col = "black")

any(!st_is_within_distance(fsAll, fsMap, dist = 100))
any(is.null(fsAll))
fsIn <- st_is_within_distance(fsAll, fsMap, dist = 1)
plot(fsIn)
summary(fsIn)

```
